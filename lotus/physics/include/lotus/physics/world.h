#pragma once

/// \file
/// Implementation of the physics world.

#include <span>

#include "lotus/physics/body.h"

namespace lotus::physics {
	/// A physics world that contains bodies that interact.
	class world {
	public:
		/// A contact point generated by collision detection.
		struct contact_info {
			/// No initialization.
			contact_info(uninitialized_t) {
			}
			/// Initializes all fields of this struct.
			[[nodiscard]] contact_info(vec3 c1, vec3 c2, vec3 n) : contact1(c1), contact2(c2), normal(n) {
			}

			vec3 contact1 = uninitialized; ///< Contact point on the first object in local space.
			vec3 contact2 = uninitialized; ///< Contact point on the second object in local space.
			/// Normalized contact normal. There's no guarantee of its direction.
			vec3 normal = uninitialized;
		};
		/// Result of collision detection.
		struct collision_info {
			/// No initialization.
			collision_info(uninitialized_t) {
			}
			/// Initializes all fields of this struct.
			collision_info(body &b1, body &b2, contact_info i) : body1(&b1), body2(&b2), contact(i) {
			}

			body *body1; ///< The first body.
			body *body2; ///< The second body.
			contact_info contact = uninitialized; ///< Information about the collision.
		};

		/// Updates this world by the given amount of time.
		[[nodiscard]] std::vector<collision_info> detect_collisions() const;

		/// Adds a body to this world.
		void add_body(body &b) {
			_bodies.emplace_back(&b);
		}
		/// Returns the list of bodies.
		[[nodiscard]] std::span<body *const> get_bodies() const {
			return _bodies;
		}


		/// Detects collision between two generic shapes. The type index of the first shape must be less than that of
		/// the second shape.
		[[nodiscard]] static std::optional<contact_info> detect_collision(
			const collision::shape&, const body_position&, const collision::shape&, const body_position&
		);
		/// Fallback case for collision detection between generic shapes - this always returns \p std::nullopt and
		/// should only be used internally.
		template <
			typename Shape1, typename Shape2
		> [[nodiscard]] static std::optional<contact_info> detect_collision(
			const Shape1&, const body_position&, const Shape2&, const body_position&
		);
		/// Detects collision between a sphere and a plane.
		[[nodiscard]] static std::optional<contact_info> detect_collision(
			const collision::shapes::plane&, const body_position&,
			const collision::shapes::sphere&, const body_position&
		);
		/// Detects collision between two spheres.
		[[nodiscard]] static std::optional<contact_info> detect_collision(
			const collision::shapes::sphere&, const body_position&,
			const collision::shapes::sphere&, const body_position&
		);
		/// Detects collision between a plane and a convex polyhedron.
		[[nodiscard]] static std::optional<contact_info> detect_collision(
			const collision::shapes::plane&, const body_position&,
			const collision::shapes::convex_polyhedron&, const body_position&
		);
		/// Detects collision between a sphere and a convex polyhedron.
		[[nodiscard]] static std::optional<contact_info> detect_collision(
			const collision::shapes::sphere&, const body_position&,
			const collision::shapes::convex_polyhedron&, const body_position&
		);
		/// Detects collision between two polyhedra.
		[[nodiscard]] static std::optional<contact_info> detect_collision(
			const collision::shapes::convex_polyhedron&, const body_position&,
			const collision::shapes::convex_polyhedron&, const body_position&
		);

		vec3 gravity = zero; ///< Gravity.
	private:
		std::vector<body*> _bodies; ///< The list of bodies in this world.
	};
}
